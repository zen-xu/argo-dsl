# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/argoproj/argo-workflows/stable/api/openapi-spec/swagger.json

from __future__ import annotations

from typing import Dict
from typing import List
from typing import Optional

from pydantic import BaseModel
from pydantic import Field

from ...k8s.api.core import v1
from ...k8s.apimachinery.pkg.apis.meta import v1 as v1_1


class Amount(BaseModel):
    value: Optional[str] = None


class Backoff(BaseModel):
    duration: Optional[str] = Field(
        None, title="Duration is the duration in nanoseconds"
    )
    factor: Optional[Amount] = Field(
        None, title="Duration is multiplied by factor each iteration"
    )
    jitter: Optional[Amount] = Field(
        None, title="The amount of jitter applied each iteration"
    )
    steps: Optional[int] = Field(None, title="Exit with error after this many steps")


class CatchupConfiguration(BaseModel):
    enabled: Optional[bool] = Field(
        None,
        title="Enabled enables to triggered the missed schedule when eventsource restarts",
    )
    maxDuration: Optional[str] = Field(
        None, title="MaxDuration holds max catchup duration"
    )


class ConfigMapPersistence(BaseModel):
    createIfNotExist: Optional[bool] = Field(
        None, title="CreateIfNotExist will create configmap if it doesn't exists"
    )
    name: Optional[str] = Field(None, title="Name of the configmap")


class DataFilter(BaseModel):
    comparator: Optional[str] = Field(
        None,
        description='Comparator compares the event data with a user given value.\nCan be ">=", ">", "=", "!=", "<", or "<=".\nIs optional, and if left blank treated as equality "=".',
    )
    path: Optional[str] = Field(
        None,
        description="Path is the JSONPath of the event's (JSON decoded) data key\nPath is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'.\nTo access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\\\'.\nSee https://github.com/tidwall/gjson#path-syntax for more information on how to use this.",
    )
    type: Optional[str] = Field(None, title="Type contains the JSON type of the data")
    value: Optional[List[str]] = Field(
        None,
        title="Value is the allowed string values for this key\nBooleans are passed using strconv.ParseBool()\nNumbers are parsed using as float64 using strconv.ParseFloat()\nStrings are taken as is\nNils this value is ignored",
    )


class DependencyGroup(BaseModel):
    dependencies: Optional[List[str]] = Field(None, title="Dependencies of events")
    name: Optional[str] = Field(None, title="Name of the group")


class EventPersistence(BaseModel):
    catchup: Optional[CatchupConfiguration] = Field(
        None,
        title="Catchup enables to triggered the missed schedule when eventsource restarts",
    )
    configMap: Optional[ConfigMapPersistence] = Field(
        None, title="ConfigMap holds configmap details for persistence"
    )


class FileArtifact(BaseModel):
    path: Optional[str] = None


class GitRemoteConfig(BaseModel):
    name: Optional[str] = Field(None, description="Name of the remote to fetch from.")
    urls: Optional[List[str]] = Field(
        None,
        description="URLs the URLs of a remote repository. It must be non-empty. Fetch will\nalways use the first URL, while push will use all of them.",
    )


class K8SResourcePolicy(BaseModel):
    backoff: Optional[Backoff] = Field(
        None, title="Backoff before checking resource state"
    )
    errorOnBackoffTimeout: Optional[bool] = Field(
        None,
        title="ErrorOnBackoffTimeout determines whether sensor should transition to error state if the trigger policy is unable to determine\nthe state of the resource",
    )
    labels: Optional[Dict[str, str]] = Field(
        None, title="Labels required to identify whether a resource is in success state"
    )


class KafkaConsumerGroup(BaseModel):
    groupName: Optional[str] = Field(
        None, title="The name for the consumer group to use"
    )
    oldest: Optional[bool] = Field(
        None,
        title="When starting up a new group do we want to start from the oldest event (true) or the newest event (false), defaults to false\n+optional",
    )
    rebalanceStrategy: Optional[str] = Field(
        None,
        title="Rebalance strategy can be one of: sticky, roundrobin, range. Range is the default.\n+optional",
    )


class LogTrigger(BaseModel):
    intervalSeconds: Optional[str] = Field(
        None,
        title="Only print messages every interval. Useful to prevent logging too much data for busy events.\n+optional",
    )


class Metadata(BaseModel):
    annotations: Optional[Dict[str, str]] = None
    labels: Optional[Dict[str, str]] = None


class Resource(BaseModel):
    value: Optional[str] = None


class S3Bucket(BaseModel):
    key: Optional[str] = None
    name: Optional[str] = None


class S3Filter(BaseModel):
    prefix: Optional[str] = None
    suffix: Optional[str] = None


class Selector(BaseModel):
    key: Optional[str] = Field(None, title="Key name")
    operation: Optional[str] = Field(
        None,
        title="Supported operations like ==, !=, <=, >= etc.\nDefaults to ==.\nRefer https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors for more io.argoproj.workflow.v1alpha1.\n+optional",
    )
    value: Optional[str] = Field(None, title="Value")


class StatusPolicy(BaseModel):
    allow: Optional[List[int]] = None


class StorageGridFilter(BaseModel):
    prefix: Optional[str] = None
    suffix: Optional[str] = None


class TimeFilter(BaseModel):
    start: Optional[str] = Field(
        None,
        description="Start is the beginning of a time window in UTC.\nBefore this time, events for this dependency are ignored.\nFormat is hh:mm:ss.",
    )
    stop: Optional[str] = Field(
        None,
        description="Stop is the end of a time window in UTC.\nAfter or equal to this time, events for this dependency are ignored and\nFormat is hh:mm:ss.\nIf it is smaller than Start, it is treated as next day of Start\n(e.g.: 22:00:00-01:00:00 means 22:00:00-25:00:00).",
    )


class TriggerParameterSource(BaseModel):
    contextKey: Optional[str] = Field(
        None,
        description="ContextKey is the JSONPath of the event's (JSON decoded) context key\nContextKey is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'.\nTo access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\\\'.\nSee https://github.com/tidwall/gjson#path-syntax for more information on how to use this.",
    )
    contextTemplate: Optional[str] = Field(
        None,
        title="ContextTemplate is a go-template for extracting a string from the event's context.\nIf a ContextTemplate is provided with a ContextKey, the template will be evaluated first and fallback to the ContextKey.\nThe templating follows the standard go-template syntax as well as sprig's extra functions.\nSee https://pkg.go.dev/text/template and https://masterminds.github.io/sprig/",
    )
    dataKey: Optional[str] = Field(
        None,
        description="DataKey is the JSONPath of the event's (JSON decoded) data key\nDataKey is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'.\nTo access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\\\'.\nSee https://github.com/tidwall/gjson#path-syntax for more information on how to use this.",
    )
    dataTemplate: Optional[str] = Field(
        None,
        title="DataTemplate is a go-template for extracting a string from the event's data.\nIf a DataTemplate is provided with a DataKey, the template will be evaluated first and fallback to the DataKey.\nThe templating follows the standard go-template syntax as well as sprig's extra functions.\nSee https://pkg.go.dev/text/template and https://masterminds.github.io/sprig/",
    )
    dependencyName: Optional[str] = Field(
        None,
        description="DependencyName refers to the name of the dependency. The event which is stored for this dependency is used as payload\nfor the parameterization. Make sure to refer to one of the dependencies you have defined under Dependencies list.",
    )
    value: Optional[str] = Field(
        None,
        description="Value is the default literal value to use for this parameter source\nThis is only used if the DataKey is invalid.\nIf the DataKey is invalid and this is not defined, this param source will produce an error.",
    )


class TriggerPolicy(BaseModel):
    k8s: Optional[K8SResourcePolicy] = Field(
        None,
        title="K8SResourcePolicy refers to the policy used to check the state of K8s based triggers using using labels",
    )
    status: Optional[StatusPolicy] = Field(
        None,
        title="Status refers to the policy used to check the state of the trigger using response status",
    )


class TriggerSwitch(BaseModel):
    all: Optional[List[str]] = Field(
        None, title="All acts as a AND operator between dependencies"
    )
    any: Optional[List[str]] = Field(
        None, title="Any acts as a OR operator between dependencies"
    )


class URLArtifact(BaseModel):
    path: Optional[str] = Field(None, title="Path is the complete URL")
    verifyCert: Optional[bool] = Field(
        None, title="VerifyCert decides whether the connection is secure or not"
    )


class WatchPathConfig(BaseModel):
    directory: Optional[str] = Field(None, title="Directory to watch for events")
    path: Optional[str] = Field(
        None,
        title="Path is relative path of object to watch with respect to the directory",
    )
    pathRegexp: Optional[str] = Field(
        None,
        title="PathRegexp is regexp of relative path of object to watch with respect to the directory",
    )


class AzureEventsHubEventSource(BaseModel):
    fqdn: Optional[str] = Field(
        None,
        title="FQDN of the EventHubs namespace you created\nMore info at https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string",
    )
    hubName: Optional[str] = Field(None, title="Event Hub path/name")
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    sharedAccessKey: Optional[v1.SecretKeySelector] = Field(
        None, title="SharedAccessKey is the generated value of the key"
    )
    sharedAccessKeyName: Optional[v1.SecretKeySelector] = Field(
        None,
        title="SharedAccessKeyName is the name you chose for your application's SAS keys",
    )


class BasicAuth(BaseModel):
    password: Optional[v1.SecretKeySelector] = Field(
        None,
        description="Password refers to the Kubernetes secret that holds the password required for basic auth.",
    )
    username: Optional[v1.SecretKeySelector] = Field(
        None,
        description="Username refers to the Kubernetes secret that holds the username required for basic auth.",
    )


class CalendarEventSource(BaseModel):
    exclusionDates: Optional[List[str]] = None
    interval: Optional[str] = Field(
        None,
        description="Interval is a string that describes an interval duration, e.g. 1s, 30m, 2h...",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    persistence: Optional[EventPersistence] = Field(
        None, title="Persistence hold the configuration for event persistence"
    )
    schedule: Optional[str] = Field(
        None,
        title="Schedule is a cron-like expression. For reference, see: https://en.wikipedia.org/wiki/Cron",
    )
    timezone: Optional[str] = Field(
        None, title="Timezone in which to run the schedule\n+optional"
    )
    userPayload: Optional[str] = Field(
        None,
        description="UserPayload will be sent to sensor as extra data once the event is triggered\n+optional\nDeprecated. Please use Metadata instead.",
    )


class Condition(BaseModel):
    lastTransitionTime: Optional[v1_1.Time] = Field(
        None,
        title="Last time the condition transitioned from one status to another.\n+optional",
    )
    message: Optional[str] = Field(
        None,
        title="Human-readable message indicating details about last transition.\n+optional",
    )
    reason: Optional[str] = Field(
        None,
        title='Unique, this should be a short, machine understandable string that gives the reason\nfor condition\'s last transition. For example, "ImageNotFound"\n+optional',
    )
    status: Optional[str] = Field(
        None, title="Condition status, True, False or Unknown.\n+required"
    )
    type: Optional[str] = Field(None, title="Condition type.\n+required")


class EventContext(BaseModel):
    datacontenttype: Optional[str] = Field(
        None,
        description="DataContentType - A MIME (RFC2046) string describing the media type of `data`.",
    )
    id: Optional[str] = Field(
        None,
        description="ID of the event; must be non-empty and unique within the scope of the producer.",
    )
    source: Optional[str] = Field(
        None, description="Source - A URI describing the event producer."
    )
    specversion: Optional[str] = Field(
        None,
        description="SpecVersion - The version of the CloudEvents specification used by the io.argoproj.workflow.v1alpha1.",
    )
    subject: Optional[str] = Field(
        None,
        title="Subject - The subject of the event in the context of the event producer",
    )
    time: Optional[v1_1.Time] = Field(
        None, description="Time - A Timestamp when the event happened."
    )
    type: Optional[str] = Field(
        None, description="Type - The type of the occurrence which has happened."
    )


class EventDependencyFilter(BaseModel):
    context: Optional[EventContext] = Field(None, title="Context filter constraints")
    data: Optional[List[DataFilter]] = Field(
        None, title="Data filter constraints with escalation"
    )
    time: Optional[TimeFilter] = Field(
        None, title="Time filter on the event with escalation"
    )


class FileEventSource(BaseModel):
    eventType: Optional[str] = Field(
        None,
        title="Type of file operations to watch\nRefer https://github.com/fsnotify/fsnotify/blob/master/fsnotify.go for more information",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    polling: Optional[bool] = Field(None, title="Use polling instead of inotify")
    watchPathConfig: Optional[WatchPathConfig] = Field(
        None,
        title="WatchPathConfig contains configuration about the file path to watch",
    )


class GenericEventSource(BaseModel):
    authSecret: Optional[v1.SecretKeySelector] = Field(
        None,
        title="AuthSecret holds a secret selector that contains a bearer token for authentication\n+optional",
    )
    config: Optional[str] = Field(
        None, title="Config is the event source configuration"
    )
    insecure: Optional[bool] = Field(
        None, description="Insecure determines the type of connection."
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    url: Optional[str] = Field(
        None, description="URL of the gRPC server that implements the event source."
    )


class GitCreds(BaseModel):
    password: Optional[v1.SecretKeySelector] = None
    username: Optional[v1.SecretKeySelector] = None


class HDFSEventSource(BaseModel):
    addresses: Optional[List[str]] = None
    checkInterval: Optional[str] = Field(
        None,
        title="CheckInterval is a string that describes an interval duration to check the directory state, e.g. 1s, 30m, 2h... (defaults to 1m)",
    )
    hdfsUser: Optional[str] = Field(
        None,
        description="HDFSUser is the user to access HDFS file system.\nIt is ignored if either ccache or keytab is used.",
    )
    krbCCacheSecret: Optional[v1.SecretKeySelector] = Field(
        None,
        description="KrbCCacheSecret is the secret selector for Kerberos ccache\nEither ccache or keytab can be set to use Kerberos.",
    )
    krbConfigConfigMap: Optional[v1.ConfigMapKeySelector] = Field(
        None,
        description="KrbConfig is the configmap selector for Kerberos config as string\nIt must be set if either ccache or keytab is used.",
    )
    krbKeytabSecret: Optional[v1.SecretKeySelector] = Field(
        None,
        description="KrbKeytabSecret is the secret selector for Kerberos keytab\nEither ccache or keytab can be set to use Kerberos.",
    )
    krbRealm: Optional[str] = Field(
        None,
        description="KrbRealm is the Kerberos realm used with Kerberos keytab\nIt must be set if keytab is used.",
    )
    krbServicePrincipalName: Optional[str] = Field(
        None,
        description="KrbServicePrincipalName is the principal name of Kerberos service\nIt must be set if either ccache or keytab is used.",
    )
    krbUsername: Optional[str] = Field(
        None,
        description="KrbUsername is the Kerberos username used with Kerberos keytab\nIt must be set if keytab is used.",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    type: Optional[str] = Field(None, title="Type of file operations to watch")
    watchPathConfig: Optional[WatchPathConfig] = None


class PubSubEventSource(BaseModel):
    credentialSecret: Optional[v1.SecretKeySelector] = Field(
        None,
        title="CredentialSecret references to the secret that contains JSON credentials to access GCP.\nIf it is missing, it implicitly uses Workload Identity to access.\nhttps://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity\n+optional",
    )
    credentialsFile: Optional[str] = Field(
        None,
        title="CredentialsFile is the file that contains credentials to authenticate for GCP\nDeprecated, use CredentialSecret instead",
    )
    deleteSubscriptionOnFinish: Optional[bool] = Field(
        None,
        title="DeleteSubscriptionOnFinish determines whether to delete the GCP PubSub subscription once the event source is stopped.\n+optional",
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    projectID: Optional[str] = Field(
        None,
        title="ProjectID is GCP project ID for the subscription.\nRequired if you run Argo Events outside of GKE/GCE.\n(otherwise, the default value is its project)\n+optional",
    )
    subscriptionID: Optional[str] = Field(
        None,
        title="SubscriptionID is ID of subscription.\nRequired if you use existing subscription.\nThe default value will be auto generated hash based on this eventsource setting, so the subscription\nmight be recreated every time you update the setting, which has a possibility of event loss.\n+optional",
    )
    topic: Optional[str] = Field(
        None,
        title="Topic to which the subscription should belongs.\nRequired if you want the eventsource to create a new subscription.\nIf you specify this field along with an existing subscription,\nit will be verified whether it actually belongs to the specified topic.\n+optional",
    )
    topicProjectID: Optional[str] = Field(
        None,
        title="TopicProjectID is GCP project ID for the topic.\nBy default, it is same as ProjectID.\n+optional",
    )


class ResourceFilter(BaseModel):
    afterStart: Optional[bool] = Field(
        None,
        title="If the resource is created after the start time then the event is treated as valid.\n+optional",
    )
    createdBy: Optional[v1_1.Time] = Field(
        None,
        title="If resource is created before the specified time then the event is treated as valid.\n+optional",
    )
    fields: Optional[List[Selector]] = Field(
        None,
        title='Fields provide field filters similar to K8s field selector\n(see https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/).\nUnlike K8s field selector, it supports arbitrary fileds like "spec.serviceAccountName",\nand the value could be a string or a regex.\nSame as K8s field selector, operator "=", "==" and "!=" are supported.\n+optional',
    )
    labels: Optional[List[Selector]] = Field(
        None,
        title="Labels provide listing options to K8s API to watch resource/s.\nRefer https://kubernetes.io/docs/concepts/overview/working-with-objects/label-selectors/ for more io.argoproj.workflow.v1alpha1.\n+optional",
    )
    prefix: Optional[str] = Field(
        None, title="Prefix filter is applied on the resource name.\n+optional"
    )


class S3Artifact(BaseModel):
    accessKey: Optional[v1.SecretKeySelector] = None
    bucket: Optional[S3Bucket] = None
    endpoint: Optional[str] = None
    events: Optional[List[str]] = None
    filter: Optional[S3Filter] = None
    insecure: Optional[bool] = None
    metadata: Optional[Dict[str, str]] = None
    region: Optional[str] = None
    secretKey: Optional[v1.SecretKeySelector] = None


class SQSEventSource(BaseModel):
    accessKey: Optional[v1.SecretKeySelector] = Field(
        None, title="AccessKey refers K8 secret containing aws access key"
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    queue: Optional[str] = Field(
        None, title="Queue is AWS SQS queue to listen to for messages"
    )
    queueAccountId: Optional[str] = Field(
        None,
        title="QueueAccountID is the ID of the account that created the queue to monitor\n+optional",
    )
    region: Optional[str] = Field(None, title="Region is AWS region")
    roleARN: Optional[str] = Field(
        None,
        title="RoleARN is the Amazon Resource Name (ARN) of the role to assume.\n+optional",
    )
    secretKey: Optional[v1.SecretKeySelector] = Field(
        None, title="SecretKey refers K8 secret containing aws secret key"
    )
    waitTimeSeconds: Optional[str] = Field(
        None,
        description="WaitTimeSeconds is The duration (in seconds) for which the call waits for a message to arrive\nin the queue before returning.",
    )


class Status(BaseModel):
    conditions: Optional[List[Condition]] = Field(
        None,
        title="Conditions are the latest available observations of a resource's current state.\n+optional\n+patchMergeKey=type\n+patchStrategy=merge",
    )


class TLSConfig(BaseModel):
    caCertPath: Optional[str] = Field(
        None,
        title="DeprecatedCACertPath refers the file path that contains the CA cert.\nDeprecated: use CACertSecret instead",
    )
    caCertSecret: Optional[v1.SecretKeySelector] = Field(
        None, title="CACertSecret refers to the secret that contains the CA cert"
    )
    clientCertPath: Optional[str] = Field(
        None,
        title="DeprecatedClientCertPath refers the file path that contains client cert.\nDeprecated: use ClientCertSecret instead",
    )
    clientCertSecret: Optional[v1.SecretKeySelector] = Field(
        None,
        title="ClientCertSecret refers to the secret that contains the client cert",
    )
    clientKeyPath: Optional[str] = Field(
        None,
        title="DeprecatedClientKeyPath refers the file path that contains client key.\nDeprecated: use ClientKeySecret instead",
    )
    clientKeySecret: Optional[v1.SecretKeySelector] = Field(
        None, title="ClientKeySecret refers to the secret that contains the client key"
    )


class TriggerParameter(BaseModel):
    dest: Optional[str] = Field(
        None,
        description="Dest is the JSONPath of a resource key.\nA path is a series of keys separated by a dot. The colon character can be escaped with '.'\nThe -1 key can be used to append a value to an existing array.\nSee https://github.com/tidwall/sjson#path-syntax for more information about how this is used.",
    )
    operation: Optional[str] = Field(
        None,
        description="Operation is what to do with the existing value at Dest, whether to\n'prepend', 'overwrite', or 'append' it.",
    )
    src: Optional[TriggerParameterSource] = Field(
        None,
        title="Src contains a source reference to the value of the parameter from a dependency",
    )


class WebhookContext(BaseModel):
    authSecret: Optional[v1.SecretKeySelector] = Field(
        None,
        title="AuthSecret holds a secret selector that contains a bearer token for authentication\n+optional",
    )
    endpoint: Optional[str] = Field(None, title="REST API endpoint")
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    method: Optional[str] = Field(
        None,
        title="Method is HTTP request method that indicates the desired action to be performed for a given resource.\nSee RFC7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content",
    )
    port: Optional[str] = Field(
        None, description="Port on which HTTP server is listening for incoming events."
    )
    serverCertPath: Optional[str] = Field(
        None,
        description="DeprecatedServerCertPath refers the file that contains the cert.",
    )
    serverCertSecret: Optional[v1.SecretKeySelector] = Field(
        None, description="ServerCertPath refers the file that contains the cert."
    )
    serverKeyPath: Optional[str] = Field(
        None, title="DeprecatedServerKeyPath refers the file that contains private key"
    )
    serverKeySecret: Optional[v1.SecretKeySelector] = Field(
        None, title="ServerKeyPath refers the file that contains private key"
    )
    url: Optional[str] = Field(None, description="URL is the url of the server.")


class AMQPEventSource(BaseModel):
    connectionBackoff: Optional[Backoff] = Field(
        None, title="Backoff holds parameters applied to connection.\n+optional"
    )
    exchangeName: Optional[str] = Field(
        None,
        title="ExchangeName is the exchange name\nFor more information, visit https://www.rabbitmq.com/tutorials/amqp-concepts.html",
    )
    exchangeType: Optional[str] = Field(
        None, title="ExchangeType is rabbitmq exchange type"
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    routingKey: Optional[str] = Field(None, title="Routing key for bindings")
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the amqp client.\n+optional"
    )
    url: Optional[str] = Field(None, title="URL for rabbitmq service")


class AWSLambdaTrigger(BaseModel):
    accessKey: Optional[v1.SecretKeySelector] = Field(
        None, title="AccessKey refers K8 secret containing aws access key"
    )
    functionName: Optional[str] = Field(
        None, description="FunctionName refers to the name of the function to invoke."
    )
    parameters: Optional[List[TriggerParameter]] = Field(None, title="+optional")
    payload: Optional[List[TriggerParameter]] = None
    region: Optional[str] = Field(None, title="Region is AWS region")
    secretKey: Optional[v1.SecretKeySelector] = Field(
        None, title="SecretKey refers K8 secret containing aws secret key"
    )


class CustomTrigger(BaseModel):
    certFilePath: Optional[str] = Field(
        None,
        title="DeprecatedCertFilePath is path to the cert file within sensor for secure connection between sensor and custom trigger gRPC server.\nDEPRECATED: use CertSecret instead",
    )
    certSecret: Optional[v1.SecretKeySelector] = Field(
        None,
        description="CertSecret refers to the secret that contains cert for secure connection between sensor and custom trigger gRPC server.",
    )
    parameters: Optional[List[TriggerParameter]] = None
    payload: Optional[List[TriggerParameter]] = None
    secure: Optional[bool] = Field(
        None,
        title="Secure refers to type of the connection between sensor to custom trigger gRPC",
    )
    serverNameOverride: Optional[str] = Field(
        None,
        description="ServerNameOverride for the secure connection between sensor and custom trigger gRPC server.",
    )
    serverURL: Optional[str] = Field(
        None,
        title="ServerURL is the url of the gRPC server that executes custom trigger",
    )
    spec: Optional[Dict[str, str]] = Field(
        None,
        description="Spec is the custom trigger resource specification that custom trigger gRPC server knows how to interpret.",
    )


class EmitterEventSource(BaseModel):
    broker: Optional[str] = Field(None, description="Broker URI to connect to.")
    channelKey: Optional[str] = Field(
        None, title="ChannelKey refers to the channel key"
    )
    channelName: Optional[str] = Field(
        None, title="ChannelName refers to the channel name"
    )
    connectionBackoff: Optional[Backoff] = Field(
        None, title="Backoff holds parameters applied to connection.\n+optional"
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    password: Optional[v1.SecretKeySelector] = Field(
        None, title="Password to use to connect to broker\n+optional"
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the emitter client.\n+optional"
    )
    username: Optional[v1.SecretKeySelector] = Field(
        None, title="Username to use to connect to broker\n+optional"
    )


class EventDependency(BaseModel):
    eventName: Optional[str] = Field(None, title="EventName is the name of the event")
    eventSourceName: Optional[str] = Field(
        None, title="EventSourceName is the name of EventSource that Sensor depends on"
    )
    filters: Optional[EventDependencyFilter] = Field(
        None,
        title="Filters and rules governing toleration of success and constraints on the context and data of an event",
    )
    name: Optional[str] = Field(None, title="Name is a unique name of this dependency")


class EventSourceStatus(BaseModel):
    status: Optional[Status] = None


class GitArtifact(BaseModel):
    branch: Optional[str] = Field(
        None, title="Branch to use to pull trigger resource\n+optional"
    )
    cloneDirectory: Optional[str] = Field(
        None,
        description="Directory to clone the repository. We clone complete directory because GitArtifact is not limited to any specific Git service providers.\nHence we don't use any specific git provider client.",
    )
    creds: Optional[GitCreds] = Field(
        None, title="Creds contain reference to git username and password\n+optional"
    )
    filePath: Optional[str] = Field(
        None, title="Path to file that contains trigger resource definition"
    )
    ref: Optional[str] = Field(
        None,
        title="Ref to use to pull trigger resource. Will result in a shallow clone and\nfetch.\n+optional",
    )
    remote: Optional[GitRemoteConfig] = Field(
        None,
        title='Remote to manage set of tracked repositories. Defaults to "origin".\nRefer https://git-scm.com/docs/git-remote\n+optional',
    )
    sshKeyPath: Optional[str] = Field(
        None,
        title="DeprecatedSSHKeyPath is path to your ssh key path. Use this if you don't want to provide username and password.\nssh key path must be mounted in sensor pod.\nDEPRECATED: use SSHKeySecret instead.\n+optional",
    )
    sshKeySecret: Optional[v1.SecretKeySelector] = Field(
        None, title="SSHKeySecret refers to the secret that contains SSH key"
    )
    tag: Optional[str] = Field(
        None, title="Tag to use to pull trigger resource\n+optional"
    )
    url: Optional[str] = Field(None, title="Git URL")


class GithubEventSource(BaseModel):
    active: Optional[bool] = Field(
        None,
        title="Active refers to status of the webhook for event deliveries.\nhttps://developer.github.com/webhooks/creating/#active\n+optional",
    )
    apiToken: Optional[v1.SecretKeySelector] = Field(
        None,
        title="APIToken refers to a K8s secret containing github api token\n+optional",
    )
    contentType: Optional[str] = Field(None, title="ContentType of the event delivery")
    deleteHookOnFinish: Optional[bool] = Field(
        None,
        title="DeleteHookOnFinish determines whether to delete the GitHub hook for the repository once the event source is stopped.\n+optional",
    )
    events: Optional[List[str]] = None
    githubBaseURL: Optional[str] = Field(
        None, title="GitHub base URL (for GitHub Enterprise)\n+optional"
    )
    githubUploadURL: Optional[str] = Field(
        None, title="GitHub upload URL (for GitHub Enterprise)\n+optional"
    )
    id: Optional[str] = Field(None, title="Id is the webhook's id")
    insecure: Optional[bool] = Field(None, title="Insecure tls verification")
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    owner: Optional[str] = Field(
        None, title="Owner refers to GitHub owner name i.e. argoproj"
    )
    repository: Optional[str] = Field(
        None, title="Repository refers to GitHub repo name i.e. argo-events"
    )
    webhook: Optional[WebhookContext] = Field(
        None, title="Webhook refers to the configuration required to run a http server"
    )
    webhookSecret: Optional[v1.SecretKeySelector] = Field(
        None,
        title="WebhookSecret refers to K8s secret containing GitHub webhook secret\nhttps://developer.github.com/webhooks/securing/\n+optional",
    )


class GitlabEventSource(BaseModel):
    accessToken: Optional[v1.SecretKeySelector] = Field(
        None,
        title="AccessToken is reference to k8 secret which holds the gitlab api access information",
    )
    deleteHookOnFinish: Optional[bool] = Field(
        None,
        title="DeleteHookOnFinish determines whether to delete the GitLab hook for the project once the event source is stopped.\n+optional",
    )
    enableSSLVerification: Optional[bool] = Field(
        None, title="EnableSSLVerification to enable ssl verification\n+optional"
    )
    events: Optional[List[str]] = Field(
        None,
        description="Events are gitlab event to listen to.\nRefer https://github.com/xanzy/go-gitlab/blob/bf34eca5d13a9f4c3f501d8a97b8ac226d55e4d9/projects.go#L794.",
    )
    gitlabBaseURL: Optional[str] = Field(
        None,
        title="GitlabBaseURL is the base URL for API requests to a custom endpoint",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    projectID: Optional[str] = Field(
        None,
        title="ProjectID is the id of project for which integration needs to setup",
    )
    webhook: Optional[WebhookContext] = Field(
        None, title="Webhook holds configuration to run a http server"
    )


class HTTPTrigger(BaseModel):
    basicAuth: Optional[BasicAuth] = Field(
        None, title="BasicAuth configuration for the http request.\n+optional"
    )
    headers: Optional[Dict[str, str]] = Field(
        None, title="Headers for the HTTP request.\n+optional"
    )
    method: Optional[str] = Field(
        None,
        title="Method refers to the type of the HTTP request.\nRefer https://golang.org/src/net/http/method.go for more io.argoproj.workflow.v1alpha1.\nDefault value is POST.\n+optional",
    )
    parameters: Optional[List[TriggerParameter]] = None
    payload: Optional[List[TriggerParameter]] = None
    timeout: Optional[str] = Field(
        None,
        title="Timeout refers to the HTTP request timeout in seconds.\nDefault value is 60 seconds.\n+optional",
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the HTTP client.\n+optional"
    )
    url: Optional[str] = Field(
        None, description="URL refers to the URL to send HTTP request to."
    )


class KafkaEventSource(BaseModel):
    connectionBackoff: Optional[Backoff] = Field(
        None, description="Backoff holds parameters applied to connection."
    )
    consumerGroup: Optional[KafkaConsumerGroup] = Field(
        None, title="Consumer group for kafka client\n+optional"
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    limitEventsPerSecond: Optional[str] = Field(
        None,
        title="Sets a limit on how many events get read from kafka per second.\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    partition: Optional[str] = Field(None, title="Partition name")
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the kafka client.\n+optional"
    )
    topic: Optional[str] = Field(None, title="Topic name")
    url: Optional[str] = Field(
        None, title="URL to kafka cluster, multiple URLs separated by comma"
    )
    version: Optional[str] = Field(
        None,
        title="Specify what kafka version is being connected to enables certain features in sarama, defaults to 1.0.0\n+optional",
    )


class KafkaTrigger(BaseModel):
    compress: Optional[bool] = Field(
        None,
        title="Compress determines whether to compress message or not.\nDefaults to false.\nIf set to true, compresses message using snappy compression.\n+optional",
    )
    flushFrequency: Optional[int] = Field(
        None,
        title="FlushFrequency refers to the frequency in milliseconds to flush batches.\nDefaults to 500 milliseconds.\n+optional",
    )
    parameters: Optional[List[TriggerParameter]] = None
    partition: Optional[int] = Field(None, description="Partition to write data to.")
    partitioningKey: Optional[str] = Field(
        None,
        description="The partitioning key for the messages put on the Kafka topic.\nDefaults to broker url.\n+optional.",
    )
    payload: Optional[List[TriggerParameter]] = None
    requiredAcks: Optional[int] = Field(
        None,
        description="RequiredAcks used in producer to tell the broker how many replica acknowledgements\nDefaults to 1 (Only wait for the leader to ack).\n+optional.",
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the Kafka producer.\n+optional"
    )
    topic: Optional[str] = Field(
        None,
        title="Name of the topic.\nMore info at https://kafka.apache.org/documentation/#intro_topics",
    )
    url: Optional[str] = Field(None, description="URL of the Kafka broker.")
    version: Optional[str] = Field(
        None,
        title="Specify what kafka version is being connected to enables certain features in sarama, defaults to 1.0.0\n+optional",
    )


class MQTTEventSource(BaseModel):
    clientId: Optional[str] = Field(None, title="ClientID is the id of the client")
    connectionBackoff: Optional[Backoff] = Field(
        None, description="ConnectionBackoff holds backoff applied to connection."
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the mqtt client.\n+optional"
    )
    topic: Optional[str] = Field(None, title="Topic name")
    url: Optional[str] = Field(None, title="URL to connect to broker")


class NATSEventsSource(BaseModel):
    connectionBackoff: Optional[Backoff] = Field(
        None, description="ConnectionBackoff holds backoff applied to connection."
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    subject: Optional[str] = Field(
        None,
        title="Subject holds the name of the subject onto which messages are published",
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the nats client.\n+optional"
    )
    url: Optional[str] = Field(None, title="URL to connect to NATS cluster")


class NATSTrigger(BaseModel):
    parameters: Optional[List[TriggerParameter]] = None
    payload: Optional[List[TriggerParameter]] = None
    subject: Optional[str] = Field(
        None, description="Name of the subject to put message on."
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the NATS producer.\n+optional"
    )
    url: Optional[str] = Field(None, description="URL of the NATS cluster.")


class NSQEventSource(BaseModel):
    channel: Optional[str] = Field(None, title="Channel used for subscription")
    connectionBackoff: Optional[Backoff] = Field(
        None, title="Backoff holds parameters applied to connection.\n+optional"
    )
    hostAddress: Optional[str] = Field(
        None, title="HostAddress is the address of the host for NSQ lookup"
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the nsq client.\n+optional"
    )
    topic: Optional[str] = Field(None, description="Topic to subscribe to.")


class OpenWhiskTrigger(BaseModel):
    actionName: Optional[str] = Field(None, description="Name of the action/function.")
    authToken: Optional[v1.SecretKeySelector] = Field(
        None, title="AuthToken for authentication.\n+optional"
    )
    host: Optional[str] = Field(None, description="Host URL of the OpenWhisk.")
    namespace: Optional[str] = Field(
        None, description='Namespace for the action.\nDefaults to "_".\n+optional.'
    )
    parameters: Optional[List[TriggerParameter]] = Field(None, title="+optional")
    payload: Optional[List[TriggerParameter]] = None
    version: Optional[str] = Field(
        None, title="Version for the API.\nDefaults to v1.\n+optional"
    )


class PulsarEventSource(BaseModel):
    connectionBackoff: Optional[Backoff] = Field(
        None, title="Backoff holds parameters applied to connection.\n+optional"
    )
    jsonBody: Optional[bool] = Field(
        None,
        title="JSONBody specifies that all event body payload coming from this\nsource will be JSON\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the pulsar client.\n+optional"
    )
    tlsAllowInsecureConnection: Optional[bool] = Field(
        None,
        title="Whether the Pulsar client accept untrusted TLS certificate from broker.\n+optional",
    )
    tlsTrustCertsSecret: Optional[v1.SecretKeySelector] = Field(
        None, title="Trusted TLS certificate secret.\n+optional"
    )
    tlsValidateHostname: Optional[bool] = Field(
        None,
        title="Whether the Pulsar client verify the validity of the host name from broker.\n+optional",
    )
    topics: Optional[List[str]] = Field(
        None, title="Name of the topics to subscribe to.\n+required"
    )
    type: Optional[str] = Field(
        None,
        title='Type of the subscription.\nOnly "exclusive" and "shared" is supported.\nDefaults to exclusive.\n+optional',
    )
    url: Optional[str] = Field(
        None, title="Configure the service URL for the Pulsar service.\n+required"
    )


class RedisEventSource(BaseModel):
    channels: Optional[List[str]] = None
    db: Optional[int] = Field(
        None, title="DB to use. If not specified, default DB 0 will be used.\n+optional"
    )
    hostAddress: Optional[str] = Field(
        None, title="HostAddress refers to the address of the Redis host/server"
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    namespace: Optional[str] = Field(
        None,
        title="Namespace to use to retrieve the password from. It should only be specified if password is declared\n+optional",
    )
    password: Optional[v1.SecretKeySelector] = Field(
        None, title="Password required for authentication if any.\n+optional"
    )
    tls: Optional[TLSConfig] = Field(
        None, title="TLS configuration for the redis client.\n+optional"
    )


class ResourceEventSource(BaseModel):
    eventTypes: Optional[List[str]] = Field(
        None,
        description="EventTypes is the list of event type to watch.\nPossible values are - ADD, UPDATE and DELETE.",
    )
    filter: Optional[ResourceFilter] = Field(
        None,
        title="Filter is applied on the metadata of the resource\nIf you apply filter, then the internal event informer will only monitor objects that pass the filter.\n+optional",
    )
    groupVersionResource: Optional[v1_1.GroupVersionResource] = Field(
        None, title="Group of the resource"
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    namespace: Optional[str] = Field(None, title="Namespace where resource is deployed")


class SNSEventSource(BaseModel):
    accessKey: Optional[v1.SecretKeySelector] = Field(
        None, title="AccessKey refers K8 secret containing aws access key"
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    region: Optional[str] = Field(None, title="Region is AWS region")
    roleARN: Optional[str] = Field(
        None,
        title="RoleARN is the Amazon Resource Name (ARN) of the role to assume.\n+optional",
    )
    secretKey: Optional[v1.SecretKeySelector] = Field(
        None, title="SecretKey refers K8 secret containing aws secret key"
    )
    topicArn: Optional[str] = Field(None, title="TopicArn")
    validateSignature: Optional[bool] = Field(
        None,
        title="ValidateSignature is boolean that can be set to true for SNS signature verification\n+optional",
    )
    webhook: Optional[WebhookContext] = Field(
        None, title="Webhook configuration for http server"
    )


class SensorStatus(BaseModel):
    status: Optional[Status] = None


class Service(BaseModel):
    clusterIP: Optional[str] = Field(
        None,
        title='clusterIP is the IP address of the service and is usually assigned\nrandomly by the master. If an address is specified manually and is not in\nuse by others, it will be allocated to the service; otherwise, creation\nof the service will fail. This field can not be changed through updates.\nValid values are "None", empty string (""), or a valid IP address. "None"\ncan be specified for headless services when proxying is not required.\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n+optional',
    )
    ports: Optional[List[v1.ServicePort]] = Field(
        None,
        title="The list of ports that are exposed by this ClusterIP service.\n+patchMergeKey=port\n+patchStrategy=merge\n+listType=map\n+listMapKey=port\n+listMapKey=protocol",
    )


class SlackEventSource(BaseModel):
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    signingSecret: Optional[v1.SecretKeySelector] = Field(
        None, title="Slack App signing secret"
    )
    token: Optional[v1.SecretKeySelector] = Field(
        None, title="Token for URL verification handshake"
    )
    webhook: Optional[WebhookContext] = Field(
        None, title="Webhook holds configuration for a REST endpoint"
    )


class SlackTrigger(BaseModel):
    channel: Optional[str] = Field(
        None,
        title="Channel refers to which Slack channel to send slack message.\n+optional",
    )
    message: Optional[str] = Field(
        None,
        title="Message refers to the message to send to the Slack channel.\n+optional",
    )
    parameters: Optional[List[TriggerParameter]] = Field(None, title="+optional")
    slackToken: Optional[v1.SecretKeySelector] = Field(
        None,
        description="SlackToken refers to the Kubernetes secret that holds the slack token required to send messages.",
    )


class StorageGridEventSource(BaseModel):
    apiURL: Optional[str] = Field(
        None, description="APIURL is the url of the storagegrid api."
    )
    authToken: Optional[v1.SecretKeySelector] = Field(
        None, title="Auth token for storagegrid api"
    )
    bucket: Optional[str] = Field(
        None, description="Name of the bucket to register notifications for."
    )
    events: Optional[List[str]] = None
    filter: Optional[StorageGridFilter] = Field(
        None, description="Filter on object key which caused the notification."
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    region: Optional[str] = Field(
        None, title="S3 region.\nDefaults to us-east-1\n+optional"
    )
    topicArn: Optional[str] = Field(None, title="TopicArn")
    webhook: Optional[WebhookContext] = Field(
        None, title="Webhook holds configuration for a REST endpoint"
    )


class StripeEventSource(BaseModel):
    apiKey: Optional[v1.SecretKeySelector] = Field(
        None,
        title="APIKey refers to K8s secret that holds Stripe API key. Used only if CreateWebhook is enabled.\n+optional",
    )
    createWebhook: Optional[bool] = Field(
        None,
        title="CreateWebhook if specified creates a new webhook programmatically.\n+optional",
    )
    eventFilter: Optional[List[str]] = Field(
        None,
        title="EventFilter describes the type of events to listen to. If not specified, all types of events will be processed.\nMore info at https://stripe.com/docs/api/events/list\n+optional",
    )
    metadata: Optional[Dict[str, str]] = Field(
        None,
        title="Metadata holds the user defined metadata which will passed along the event payload.\n+optional",
    )
    webhook: Optional[WebhookContext] = Field(
        None, title="Webhook holds configuration for a REST endpoint"
    )


class ArtifactLocation(BaseModel):
    configmap: Optional[v1.ConfigMapKeySelector] = Field(
        None, title="Configmap that stores the artifact"
    )
    file: Optional[FileArtifact] = Field(
        None, title="File artifact is artifact stored in a file"
    )
    git: Optional[GitArtifact] = Field(
        None, title="Git repository hosting the artifact"
    )
    inline: Optional[str] = Field(
        None, title="Inline artifact is embedded in sensor spec as a string"
    )
    resource: Optional[Resource] = Field(
        None, title="Resource is generic template for K8s resource"
    )
    s3: Optional[S3Artifact] = Field(None, title="S3 compliant artifact")
    url: Optional[URLArtifact] = Field(None, title="URL to fetch the artifact from")


class StandardK8STrigger(BaseModel):
    groupVersionResource: Optional[v1_1.GroupVersionResource] = Field(
        None,
        title="The unambiguous kind of this object - used in order to retrieve the appropriate kubernetes api client for this resource",
    )
    liveObject: Optional[bool] = Field(
        None,
        title='LiveObject specifies whether the resource should be directly fetched from K8s instead\nof being marshaled from the resource artifact. If set to true, the resource artifact\nmust contain the information required to uniquely identify the resource in the cluster,\nthat is, you must specify "apiVersion", "kind" as well as "name" and "namespace" meta\ndata.\nOnly valid for operation type `update`\n+optional',
    )
    operation: Optional[str] = Field(
        None,
        title="Operation refers to the type of operation performed on the k8s resource.\nDefault value is Create.\n+optional",
    )
    parameters: Optional[List[TriggerParameter]] = None
    patchStrategy: Optional[str] = Field(
        None,
        title='PatchStrategy controls the K8s object patching strategy when the trigger operation is specified as patch.\npossible values:\n"application/json-patch+json"\n"application/merge-patch+json"\n"application/strategic-merge-patch+json"\n"application/apply-patch+yaml".\nDefaults to "application/merge-patch+json"\n+optional',
    )
    source: Optional[ArtifactLocation] = Field(
        None, title="Source of the K8 resource file(s)"
    )


class ArgoWorkflowTrigger(BaseModel):
    groupVersionResource: Optional[v1_1.GroupVersionResource] = Field(
        None,
        title="The unambiguous kind of this object - used in order to retrieve the appropriate kubernetes api client for this resource",
    )
    operation: Optional[str] = Field(
        None,
        title="Operation refers to the type of operation performed on the argo workflow resource.\nDefault value is Submit.\n+optional",
    )
    parameters: Optional[List[TriggerParameter]] = None
    source: Optional[ArtifactLocation] = Field(
        None, title="Source of the K8 resource file(s)"
    )


class TriggerTemplate(BaseModel):
    argoWorkflow: Optional[ArgoWorkflowTrigger] = Field(
        None,
        title="ArgoWorkflow refers to the trigger that can perform various operations on an Argo io.argoproj.workflow.v1alpha1.\n+optional",
    )
    awsLambda: Optional[AWSLambdaTrigger] = Field(
        None,
        title="AWSLambda refers to the trigger designed to invoke AWS Lambda function with with on-the-fly constructable payload.\n+optional",
    )
    conditions: Optional[str] = Field(
        None,
        title='Conditions is the conditions to execute the trigger.\nFor example: "(dep01 || dep02) && dep04"\n+optional',
    )
    custom: Optional[CustomTrigger] = Field(
        None,
        title="CustomTrigger refers to the trigger designed to connect to a gRPC trigger server and execute a custom trigger.\n+optional",
    )
    http: Optional[HTTPTrigger] = Field(
        None,
        title="HTTP refers to the trigger designed to dispatch a HTTP request with on-the-fly constructable payload.\n+optional",
    )
    k8s: Optional[StandardK8STrigger] = Field(
        None,
        title="StandardK8STrigger refers to the trigger designed to create or update a generic Kubernetes resource.\n+optional",
    )
    kafka: Optional[KafkaTrigger] = Field(
        None,
        description="Kafka refers to the trigger designed to place messages on Kafka topic.\n+optional.",
    )
    log: Optional[LogTrigger] = Field(
        None,
        title="Log refers to the trigger designed to invoke log the io.argoproj.workflow.v1alpha1.\n+optional",
    )
    name: Optional[str] = Field(
        None, description="Name is a unique name of the action to take."
    )
    nats: Optional[NATSTrigger] = Field(
        None,
        description="NATS refers to the trigger designed to place message on NATS subject.\n+optional.",
    )
    openWhisk: Optional[OpenWhiskTrigger] = Field(
        None,
        title="OpenWhisk refers to the trigger designed to invoke OpenWhisk action.\n+optional",
    )
    slack: Optional[SlackTrigger] = Field(
        None,
        title="Slack refers to the trigger designed to send slack notification message.\n+optional",
    )
    switch: Optional[TriggerSwitch] = Field(
        None,
        title="DeprecatedSwitch is the condition to execute the trigger.\nDEPRECATED: USE conditions instead\n+optional",
    )


class Template(BaseModel):
    container: Optional[v1.Container] = Field(
        None,
        title="Container is the main container image to run in the sensor pod\n+optional",
    )
    imagePullSecrets: Optional[List[v1.LocalObjectReference]] = Field(
        None,
        title="ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.\nIf specified, these secrets will be passed to individual puller implementations for them to use. For example,\nin the case of docker, only DockerConfig type secrets are honored.\nMore info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod\n+optional\n+patchMergeKey=name\n+patchStrategy=merge",
    )
    metadata: Optional[Metadata] = Field(
        None, title="Metadata sets the pods's metadata, i.e. annotations and labels"
    )
    nodeSelector: Optional[Dict[str, str]] = Field(
        None,
        title="NodeSelector is a selector which must be true for the pod to fit on a node.\nSelector which must match a node's labels for the pod to be scheduled on that node.\nMore info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n+optional",
    )
    securityContext: Optional[v1.PodSecurityContext] = Field(
        None,
        title="SecurityContext holds pod-level security attributes and common container settings.\nOptional: Defaults to empty.  See type description for default values of each field.\n+optional",
    )
    serviceAccountName: Optional[str] = Field(
        None,
        title="ServiceAccountName is the name of the ServiceAccount to use to run sensor pod.\nMore info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\n+optional",
    )
    tolerations: Optional[List[v1.Toleration]] = Field(
        None, title="If specified, the pod's tolerations.\n+optional"
    )
    volumes: Optional[List[v1.Volume]] = Field(
        None,
        title="Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.\n+patchStrategy=merge\n+patchMergeKey=name\n+optional",
    )


class Trigger(BaseModel):
    parameters: Optional[List[TriggerParameter]] = Field(
        None,
        title="Parameters is the list of parameters applied to the trigger template definition",
    )
    policy: Optional[TriggerPolicy] = Field(
        None, title="Policy to configure backoff and execution criteria for the trigger"
    )
    template: Optional[TriggerTemplate] = Field(
        None, description="Template describes the trigger specification."
    )


class EventSourceSpec(BaseModel):
    amqp: Optional[Dict[str, AMQPEventSource]] = Field(None, title="AMQP event sources")
    azureEventsHub: Optional[Dict[str, AzureEventsHubEventSource]] = Field(
        None, title="AzureEventsHub event sources"
    )
    calendar: Optional[Dict[str, CalendarEventSource]] = Field(
        None, title="Calendar event sources"
    )
    emitter: Optional[Dict[str, EmitterEventSource]] = Field(
        None, title="Emitter event source"
    )
    eventBusName: Optional[str] = Field(
        None,
        title='EventBusName references to a EventBus name. By default the value is "default"',
    )
    file: Optional[Dict[str, FileEventSource]] = Field(None, title="File event sources")
    generic: Optional[Dict[str, GenericEventSource]] = Field(
        None, title="Generic event source"
    )
    github: Optional[Dict[str, GithubEventSource]] = Field(
        None, title="Github event sources"
    )
    gitlab: Optional[Dict[str, GitlabEventSource]] = Field(
        None, title="Gitlab event sources"
    )
    hdfs: Optional[Dict[str, HDFSEventSource]] = Field(None, title="HDFS event sources")
    kafka: Optional[Dict[str, KafkaEventSource]] = Field(
        None, title="Kafka event sources"
    )
    minio: Optional[Dict[str, S3Artifact]] = Field(None, title="Minio event sources")
    mqtt: Optional[Dict[str, MQTTEventSource]] = Field(None, title="MQTT event sources")
    nats: Optional[Dict[str, NATSEventsSource]] = Field(
        None, title="NATS event sources"
    )
    nsq: Optional[Dict[str, NSQEventSource]] = Field(None, title="NSQ event source")
    pubSub: Optional[Dict[str, PubSubEventSource]] = Field(
        None, title="PubSub event sources"
    )
    pulsar: Optional[Dict[str, PulsarEventSource]] = Field(
        None, title="Pulsar event source"
    )
    redis: Optional[Dict[str, RedisEventSource]] = Field(
        None, title="Redis event source"
    )
    replica: Optional[int] = Field(
        None, title="Replica is the event source deployment replicas"
    )
    resource: Optional[Dict[str, ResourceEventSource]] = Field(
        None, title="Resource event sources"
    )
    service: Optional[Service] = Field(
        None,
        title="Service is the specifications of the service to expose the event source\n+optional",
    )
    slack: Optional[Dict[str, SlackEventSource]] = Field(
        None, title="Slack event sources"
    )
    sns: Optional[Dict[str, SNSEventSource]] = Field(None, title="SNS event sources")
    sqs: Optional[Dict[str, SQSEventSource]] = Field(None, title="SQS event sources")
    storageGrid: Optional[Dict[str, StorageGridEventSource]] = Field(
        None, title="StorageGrid event sources"
    )
    stripe: Optional[Dict[str, StripeEventSource]] = Field(
        None, title="Stripe event sources"
    )
    template: Optional[Template] = Field(
        None, title="Template is the pod specification for the event source\n+optional"
    )
    webhook: Optional[Dict[str, WebhookContext]] = Field(
        None, title="Webhook event sources"
    )


class SensorSpec(BaseModel):
    circuit: Optional[str] = Field(
        None,
        description="Circuit is a boolean expression of dependency groups\nDEPRECATED: Use Switch in triggers instead.",
    )
    dependencies: Optional[List[EventDependency]] = Field(
        None,
        description="Dependencies is a list of the events that this sensor is dependent on.",
    )
    dependencyGroups: Optional[List[DependencyGroup]] = Field(
        None, description="DependencyGroups is a list of the groups of events."
    )
    errorOnFailedRound: Optional[bool] = Field(
        None,
        description="ErrorOnFailedRound if set to true, marks sensor state as `error` if the previous trigger round fails.\nOnce sensor state is set to `error`, no further triggers will be processed.",
    )
    eventBusName: Optional[str] = Field(
        None,
        title='EventBusName references to a EventBus name. By default the value is "default"',
    )
    template: Optional[Template] = Field(
        None, title="Template is the pod specification for the sensor\n+optional"
    )
    triggers: Optional[List[Trigger]] = Field(
        None,
        description="Triggers is a list of the things that this sensor evokes. These are the outputs from this sensor.",
    )


class EventSource(BaseModel):
    metadata: Optional[v1_1.ObjectMeta] = None
    spec: Optional[EventSourceSpec] = None
    status: Optional[EventSourceStatus] = None


class EventSourceList(BaseModel):
    items: Optional[List[EventSource]] = None
    metadata: Optional[v1_1.ListMeta] = None


class Sensor(BaseModel):
    metadata: Optional[v1_1.ObjectMeta] = None
    spec: Optional[SensorSpec] = None
    status: Optional[SensorStatus] = None


class SensorList(BaseModel):
    items: Optional[List[Sensor]] = None
    metadata: Optional[v1_1.ListMeta] = None
